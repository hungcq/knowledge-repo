# Solution architecture discussion
- 5 pillars:
  - Cost
  - Performance
  - Reliability
  - Security
  - Operational excellence
- WhatIsTheTime: stateless web app:
  - 1 instance, scaling vertically
  - -> Elastic IP
  - Scaling horizontally
  - -> DNS, A record, multiple IPs
  - -> DNS, Alias record + ELB + health check for availability
  - Autoscaling group: reduce manual operation effort
  - -> Multi AZs for availability
  - Reserved instance for cost saving
- MyClothes: stateful web app: online shopping with cart:
  - ELB stateful session: maintain user session
  - -> Cookies: heavy request, need validation
  - -> Server session in ElastiCache/DynamoDB, session ID stored in cookies
  - RDS stores user data
  - -> Cache/read replicas to scale read
  - Multi Azs for ELB, ASG, RDS, ElastiCache for availability
  - Security group ref each other to restrict to private traffic (except LB) for security
- MyWordPress: global scale, support picture upload & access:
  - File storage: EBS volume attach to 1 EC2 instance
  - -> EFS for scalability, use ENI attached to EC2 instances to connect to EFS
  - Aurora RDS for easy multi AZs & read replicas
- Instantiate apps quickly:
  - EC2: use Golden AMI: install OS, app dependencies beforehand
  - -> Beanstalk to mix Golden AMI & dynamic user data script
  - RDS DB: restore from snapshot -> schema ready
  - EBS volume: restore from snapshot: disk formatted & have data
- Elastic Beanstalk:
  - Def: dev centric view of deploying an app on AWS
  - -> Managed service, dev do configuration & code
  - Use commonly used components: eg EC2, ASG, ELB, RDS
  - Cost:
    - Beanstalk: free
    - Other components: cost money
  - Components:
    - App: collections of Beanstalk components (envs, versions, configs)
    - App version: iteration of app code
    - Env:
      - Def: collection of AWS resources running an app version
      - Tiers: web env tier & worker env tier (process work using queue, scale based on queue load)
      - Can create multiple env
    - Process: create app -> upload app version -> launch env -> manage env
    - Deployment mode:
      - Single instance: suitable for dev
      - High availability with LB & RDS failover: suitable for production
- Snowball to Glacier: snowball -> S3 -> Glacier (via lifecycle policy)
- ECS:
  - ECS task invoked by EventBridge: client -> S3 bucket -> EventBridge event -> ECS task: get object from S3 -> DynamoDB
  - ECS task invoke by EventBridge schedule: EventBridge event every 1 hour -> ECS task: batch processing -> S3
  - ECS - SQS queue: autoscaling tasks poll for SQS messages
  - ECS intercept stopped tasks using EventBridge: exited ECS task -> EventBridge event -> SNS: email -> admin
## Serverless
- MyTodoList: serverless mobile app:
  - Requirements:
    - REST APIs with HTTP
    - User can interact with their dir in S3: use Cognito + Security Token Service (STS)
    - Authentication
  - Architecture: client -> API Gateway -> Lambda -> DynamoDB. Authentication: client -> Cognito <-> API Gateway
  - -> Improve read throughput: DAX, cache at API Gateway
- MyBlog.com: serverless website:
  - Requirements:
    - Scale globally
    - Send welcome email to new users
    - HTTP APIs
    - Serve static files: 
    - Generate thumbnail
    - Caching
  - Flow:
    - Static content: client -> CloudFront -> S3 (secured with bucket policy)
    - API call: client -> API Gateway -> Lambda -> DAX -> DynamoDB Global Tables -> Stream -> Lambda -> Simple Email Service (SES)
    - Thumbnail generation: client -> CloudFront -> S3 -> Lambda -> S3
- Microservices: options:
  - ELB -> ECS
  - API Gateway -> Lambda
  - ELB -> EC2 ASG
- Software updates offloading:
  - Problem: app on EC2 distributing software updates occasionally -> costly networking
  - Solution: add CloudFront on top to distribute static update files
  - -> No code change needed
## Data storage use cases
- RDS: OLTP
- Aurora: ~RDS, better performance, more features
- ElastiCache (require code change): key value store, session data, DB cache
- DynamoDB: evolving schema, DB for serverless app, serverless cache
- S3: big objects: static file, KV store for big files, website hosting
- DocumentDB (managed MongoDB): ~Aurora for document DB
- Neptune (graph DB): knowledge graph, fraud detection, recommendation engine, social networking
- Keyspaces (managed Apache Cassandra)
- Quantum ledger database (QLDB):
  - Ledger DB: immutable, record all changes to data, cryptographically verifiable
  - Vs Managed Blockchain: centralized DB -> comply with financial laws
- Timestream (time series DB): sample architecture: Prometheus -> Timestream -> Grafana
## Big Data Ingestion Pipeline
- IoT devices -> Kinesis Data Streams -> Firehose <-> Lambda transformation -> S3 ingestion bucket
  -> Lambda -> Athena (process ingestion bucket) -> S3 reporting bucket -> Redshift/Quicksight
## CloudTrail - EventBridge integration
- API call interception: API call in AWS services -> CloudTrail: event -> EventBridge -> SNS
## DDoS protection
- Edge location layer: protected at CloudFront, GA, Route53
- Infra layer defense: protect EC2 against high traffic:
  - Edge location mitigation approaches
  - EC2 with ASG & ELB
- Application layer:
  - CloudFront for static content
  - WAF in front of ALB
  - Shield Advanced
- Attack surface reduction:
  - Obfuscating AWS resources (hide BE with API Gateway, ELB, CloudFront)
  - Security groups & network ACLs
  - Protect API endpoints: hide BE, CloudFront, WAF + API Gateway
## VPC Flow Logs:
- Flow Logs -> CW Logs -> CW Contributor Insights -> Top IP addresses
- Flow Logs -> CW Logs -> Metric Filter -> CW Alarm -> SNS
- Flow Logs -> S3 -> Athena -> QuickSight (visualization)
## Event processing
- Setup dead letter queue to avoid infinite retry SQS -> Lambda: SQS -> DLQ
- SNS -> Lambda (async) -> DLQ
- Fanout pattern (see Messaging)
- S3 events -> SNS, SQS, Lambda, EventBridge
- Intercept API call with EventBridge (see CloudTrail - EventBridge integration)
- Client -> requests -> API Gateway -> Kinesis Data Streams -> Firehose -> S3
## Caching
- Tradeoff: cache at edge: faster, less network cost, less computation, risk of stale data
## Blocking IP
- NACL: both deny & allow rules
- Security group: allow IPs
- Optional firewall software in EC2
- NLB: no security group, BE can see client IP
- -> Can install WAF IP filtering
- CloudFront: ALB can't see client IP, but CloudFront public IP -> NACL not helpful
- -> Can use CloudFront Geo Restriction or WAF IP filtering
## High performance computing (HPC)
- Suitable on cloud since resources can be scaled on demand
- EC2 Enhanced Networking. Options:
  - Use Elastic Network Adapter (ENA)
  - Intel adapter
- Elastic Fabric Adapter:
  - Improved ENA for HPC, only work for Linux
  - Great for inter-node communications, tightly coupled workload
- Automation & orchestration:
  - AWS Batch
  - ParallelCluster:
    - Def: open source cluster management tool to deploy HPC on AWS
    - Can create EFA on the cluster to improve network performance
## Highly available EC2 instance
- CW Event/Alarm based on metric -> Lambda function -> Start attach Elastic IP to standby instance
- Multi AZ ASG: 1 min 1 max 1 desired num of instances
- With EBS:
  - Use ASG Terminate lifecycle hook: create EBS snapshot
  - ASG Launch lifecycle hook: launch new volume & attach on new EC2