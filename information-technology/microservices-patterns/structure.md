# Structure
## Outline
- Chap 1 & 2:
  - Basic concepts
  - Problem of monolithic, when and why to use microservice architecture
  - Advs & disadvs of microservice architecture
  - Microservice patterns as a solution
  - Defining application architecture:
    - Decompose & define services
    - Define APIs
- Chap 3-12: problems & patterns:
  - Interprocess communication
  - Managing transactions
  - Designing business logic
  - Implementing queries
  - Designing external APIs for various types of client
  - Automated testing for microservices
  - Developing production-ready services:
    - Security
    - Configuration
    - Observability
    - Deployment
- Chap 13: refactoring from monolithic to microservice architecture: difficulty & strategies

## Detailed structure
- Preface:
  - History of microservice architecture
  - The problems & how they will be addressed in the book
  - Reason to organize the book around patterns
- Chap 1:
  - Monolithic & microservice architecture: usage, advs & disadvs
  - Pattern & pattern language: def, characteristics, advs
  - Microservice pattern language: def, 3 layers, pattern groups
  - Process & organization: when working with microservice architecture
- Chap 2:
  - Concepts related to software architecture:
    - Dif views of architecture
    - Architectural styles: hexagonal, microservices
  - Steps to define microservice architecture for an app:
    - Identify system operations
    - Define services: difficulties & solution
    - Define API
- Chap 3:
  - Design issues related to IPC:
    - Types of interaction
    - Define & evolve API
    - Message format
  - RPC: advs, disadvs, design issues, technologies
  - Messaging:
    - How to implement dif interaction styles
    - API def
    - 2 types of architecture, advs & disadvs: broker-less vs broker-based
    - Design issues
    - Techs
    - How to replace sync interactions to increase availability
- Chap 4:
  - Overview of trans management & 2 approaches: distributed trans & saga
  - 2 types of saga: example advs & disadvs:
    - Choreography
    - Orchestration
  - Design issues when using saga:
    - Transactional mes: solved
    - Lack of isolation: types, dif solutions with examples
  - Code example of orchestration saga
- Chap 5:
  - Design business logic in each service:
    - Transaction script pattern
    - Domain model pattern -> Domain driven design
    - Publish domain event: domain event pattern
  - 2 examples of business logic design
- Chap 6:
  - Traditional persistence: approach & problems
  - Event sourcing: def, char, advs & disadvs, design issues
  - Event store: architecture & example
  - Using saga with event sourcing:
    - Choreography-based saga: problems
    - Orchestration-based saga: design issues
- Chap 7:
  - API composition: architecture, design issues, advs & disadvs, usage
  - CQRS (same as above):
    - Design decisions
    - How to build/rebuild view
  - Example of CQRS design
- Chap 8:
  - Problems with client-invoking-services approaches
  - -> API gateway as solution
  - API gateway:
    - Functions
    - Architecture
    - Advs & disadvs
    - Design issues
  - API gw techs, considerations & examples:
    - Off-the-shelf solutions
    - Frameworks to dev your own
    - Graph API techs
- Chap 9:
  - Automated testing vs manual testing
  - Testing microservices overview:
    - Def, concepts, types
    - Test double: usage & types
    - Testing services interaction: consumer driven contract testing: concepts & process
    - Deployment pipeline with tests
  - Unit testing guide with example for dif type of classes in a service: setup, execution & verification:
    - Entities & value object
    - Saga
    - Domain service
    - HTTP request handler
    - Message handler
- Chap 10:
  - Integration test for dif types of interactions with examples:
    - Persistent
    - HTTP req/res
    - Publish/subscribe
    - Async req/res
  - Component tests:
    - Approaches -> use DSL
    - Types & implementation
    - Setup & run
  - End-to-end tests: consideration, implementation, setup & run
- Chap 11:
  - Security: authentication & authorization:
    - Review of security in monolith
    - In microservice: architecture, token approach, OAuth standard & archi
  - Configuration: problems, push-based & pull-based external config: design, advs & disadvs
  - Observability aspects, architecture & techs:
    - Health check
    - Log
    - Distributed tracing
    - Exception tracking
    - App metric
    - Audit log
  - Microservice chassis & service mesh: def, overview, techs
- Chap 12:
  - Overview of deployment: def, history, functions of production env
  - 4 deployment patterns: architecture, pipeline, process, advs & disadvs:
    - Language-specific package
    - Virtual machine
    - Container
    - Serverless
  - Technologies: architecture, deployment & upgrade process with examples:
    - Docker
    - Kubernetes
    - Istio
    - AWS lambda
- Chap 13:
  - Overview: consideration before refactoring, non-strat and overview of strangler strat
  - 3 main strangling strats: usage, advs, design issues:
    - Implement new features as services
    - Separate presentation tier and backend
    - Extract business capabilities into services
  - Design collaboration between service and monolith: architecture, design issues:
    - Design integration glue
    - Maintain data consistency
    - Handle authentication & authorization
  - Refactoring examples using strat 1 and 3